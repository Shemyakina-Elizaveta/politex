/**
 * Практическое занятие №2. Побитовые операторы. Директивы препроцессора.
 * Указатели.
 */

#define _USE_MATH_DEFINES

#define LENGTH(radius) (2 * (radius) * M_PI)
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define EXCHANGE(X, Y) {int tmp = X; X = Y; Y = tmp;}
  

#include <iostream>
#include <cmath>

#ifndef NDEBUG
  #include "h1.h"
#else
  #include "h2.h"
#endif

int main()
{
  /**
   * Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
   */

   /**
    * Задание 1.1.
    *
    * Задайте значение переменной `y`, например, с помощью потока ввода.
    *
    * 1. С помощью побитовых операторов и операторов сдвига выведите значение
    *    переменной `y` на консоль в двоичном виде.
    * 2. Сделайте то же, но пропустив незначащие нули.
    *
    * Например, если `y == 9`, то должно получиться
    * 1. `0 0 0 0 ... 0 0 1 0 0 1` (количество двоичных цифр зависит от
    *    платформы).
    * 2. `1 0 0 1`.
    *
    * Что выведет ваша программа, если ввести отрицательное число? Объясните
    * этот результат.
    */


  {
    int y, size = 0;
    const int bsize = sizeof(int) * 8;
    int buf[bsize];

    std::cout << "ex 1.1\n";
    std::cout << "Enter y: ";
    std::cin >> y;

    for (int i = bsize - 1; i >= 0; i--)
    {
      buf[i] = y & 1;
      size += (y != 0);
      y = y >> 1;
    }

    for (int i = 0; i < bsize; i++)
      std::cout << buf[i];

    std::cout << '\n';

    for (int i = bsize - size; i < bsize; i++)
      std::cout << buf[i];

    std::cout << '\n';
  }
  /**
   * Задание 1.2.
   *
   * Дана целая переменная `y`, задайте ее значение, например, с помощью
   * потока ввода.
   *
   * В рамках одного цикла "сдвиньте" все единицы в переменной `y` вправо,
   * обновив тем самым значение этой переменной.
   *
   * Например:
   * было:  0100 1111 0000 0000 0110 1111 0000 0010
   * стало: 0000 0000 0000 0000 0000 1111 1111 1111
   *
   * Выведите переменную на экран в двоичном виде до преобразования и после,
   * используя код из задания 1.1.
   */

  {
    int y;
    const int bsize = sizeof(int) * 8;
    char buf1[bsize], buf2[bsize];

    for (int i = 0; i < bsize; i++)
      buf2[i] = '0';

    std::cout << "ex 1.2\n";
    std::cout << "Enter y: ";
    std::cin >> y;

    int j = bsize - 1;

    for (int i = bsize - 1; i >= 0; i--)
    {
      buf1[i] = (y & 1) + '0';
      if (y & 1)
        buf2[j--] = (y & 1) + '0';
      y = y >> 1;
    }

    for (int i = 0; i < 32; i++)
      std::cout << buf1[i] << ' ';

    std::cout << '\n';

    for (int i = 0; i < 32; i++)
      std::cout << buf2[i] << ' ';

    std::cout << '\n';
  }


  /**
   * Задание 1.3.
   *
   * Дана целая переменная `y`, задайте ее значение.
   *
   * Напишите код, который с помощью побитовых операций:
   *
   * 1. вычислит `y * 2^n`, где целое `n` (0 <= n < 16) задается отдельно;
   * 2. проверит, делится ли `y` на 2, проверит, делится ли `y` на 4;
   * 3. вычислит целую часть логорифма `y` по основанию 2.
   */

  {
    int y, n;

    std::cout << "ex 1.3\n";
    std::cout << "Enter y: ";
    std::cin >> y;

    std::cout << "Enter n (0 <= n < 16): ";
    std::cin >> n;

    std::cout << "y * 2^n = " << (y << n) << '\n';
    std::cout << "y % 2 = " << (y & 1) << " y % 4 = " << (y & 3) << '\n';

    int log = 0;

    while (y > 1)
    {
      log += 1;
      y = y >> 1;
    }

    std::cout << "log2(y) = " << log - 1 << '\n';
  }

  /**
   * Задание 1.4.
   *
   * Какие операции следует применить к заданному ниже операнду sNum для
   * того, чтобы переменная sRes приняла требуемое значение? Каждую побитовую
   * операцию можно использовать только 1 раз.
   *
   * Замечание: значения подобраны таким образом, что в каждом случае
   * достаточно использовать один оператор (и при необходимости маску).
   */

  {
    short sNum = 0x8008;
    short sRes;

    /** sRes == 0x7ff7 */
    sRes = ~sNum;
    
    /** sRes == 0x8ff8 */
    sRes = sNum | 0x0ff0;
    
    /** sRes == 0x0008 */
    sRes = sNum & 0x000f;

    /** sRes == 0x7f08 */
    sRes = sNum ^ 0xff00;

    /** sRes == 0xf001 */
    sRes = sNum >> 3;
    // перевод в 2 сс sNum -> sNum = -2^3 * 2^4 * 2^4 * 2^4 + 2^3 = -32760 -> sNum >> 3
    // -> sNum = -2^4 * 2^4 * 2^4 + 1 = -4095 -> перевод в 16 сс -> sRes = 0xf001


    /** sRes == 0x0010 */
    sRes = sNum << 1;
    // перевод в 2 сс sNum -> sNum = -2^3 * 2^4 * 2^4 * 2^4 + 2^3 = -32760 -> sNum << 1
    // sNum = -2^4 * 2^4 * 2^4 * 2^4 + 2^4 = -65520 -> выход за разрядную сетку short -> sNum = 16
    // -> перевод в 16 сс -> sRes = 0x0010
  }

  /**
   * Задание 2. Директивы препроцессора.
   */

   /**
    * Задание 2.1. Использование "математических" макросов стандартной
    * библиотеки.
    *
    * В заголовочном файле <cmath> (который в свою очередь включает старый
    * файл math.h) определены часто используемые математические константы,
    * например M_PI. Воспользуйтесь этой константой для вычисления длины
    * окружности.
    */

  {
    float radius = 1;
    float circumference = 2 * M_PI * radius;
  }

  /**
   * Задание 2.2. Макросы с параметрами.
   */

   /**
    * Задание 2.2.1.
    *
    * Напишите свою макроподстановку LENGTH которая вычисляет длину
    * окружности.
    */

  {
    /** Протестируйте написанный макрос для следующих ситуаций */

    float l1 = LENGTH(1 + 2); // должно быть 18.8495...
    float l2 = 1 / LENGTH(2); // должно быть 0.07957...   // TODO: перепроверить, починить - сделано
    std::cout << "l2 = " << l2 << '\n';
  }

  /**
   * Задание 2.2.2.
   *
   * Определите макрос MAX(A, B) для вычисления б'ольшего значения из двух.
   */

  {
    /**
     * Используйте макрос следующим образом. Следите за изменением значений
     * переменных k, i, j. Объясните результат.
     *
     * Постарайтесь убрать побочные эффекты.
     *
     * Отметьте случаи, когда избежать побочных эффектов невозможно.
     */

     int i = 10, j = 12, k;
     k = MAX(i, j); // 12
     k = MAX(j, i) * 2; // 24
     k = MAX(j, i+3); // 13
     k = MAX(i--, j++); // 13; ошибка?

  }

  /**
   * Задание 2.2.3.
   *
   * Определите макрос EXCHANGE(X, Y)  для перестановки двух объектов типа
   * int в памяти местами.
   *
   * Проверьте для приведенного фрагмента.
   *
   * Подумайте, что будет делать макроподстановка, если переставляемые
   * значения разного типа???
   */
  {
    int x1=1, y1=-1;
    EXCHANGE(x1,y1);

    // если типы переменных будут разными, то макрос будет преобразовывать эти типы к указанному, а потом обратно записывать 

    int x2=100, y2=-100;
    EXCHANGE(x2,y2);
  }

  /**
   * Задание 2.3. Директивы условной трансляции.
   *
   * Выполняя следующий фрагмент, посмотрите, какое значение принимает
   * переменная iNN.
   *
   * Что нужно сделать для того, чтобы результат был равен 0? 1? 2?
   */

  {
    int iNN;

#if defined NNN && defined MMM
    iNN = 0;
#elif defined MMM
    iNN = 1;
#elif defined NNN 
    iNN = 2;
#else
    iNN = -1;
#endif

    // iNN = -1; чтобы iNN = 0, нужно определить NNN и MMM
    // чтобы iNN = 1, нужно определить только MMM
    // чтобы iNN = 2, нужно определить только NNN
  }

  /**
   * Задание 2.4. Задание директив при сборке.
   *
   * При сборке программы компилятором можно установить необходимые
   * макроподстановки с помощью ключа `-D`. Например, чтобы при сборке
   * была определена директива `A` без значения и директива `B` со значением
   * `1`, надо добавить следующие ключи к команде сборки: `-D A -D B=1`.
   * Таким образом команда сборки будет выглядеть примерно так:
   *
   * `gcc -g -D A -D B=1 lab2.cpp`
   *
   * Уберите из кода определения макросов NNN и MMM из прошлого задания и
   * приведите команды компиляции, которые заставят переменную iNN принять
   * нужное значение.
   *
   * Проверьте их работоспособность.
   */

   /**
    * Задание 2.5. Сборки "DEBUG" и "RELEASE". Предопределенные макросы
    * компилятора.
    *
    * При отладке удобно выводить дополнительную информацию, которая может
    * мешать в итоговой (релизной) версии программы.
    *
    * Существует стандартный макрос, который принято устанавливать при
    * релизной сборке - `NDEBUG`.
    *
    * С помощью макроса NDEBUG и предопределенных макросов выведите на консоль
    * для отладочной версии информацию о том, что это отладочная сборка, о
    * дате сборки, о имени файла, имени функции и строки. Для релизной сборки
    * такая информация не должна выводиться.
    *
    * Для защиты работы соберите две версии программы: отладочную и итоговую.
    * Чтобы собрать итоговую версию в другом исполняемом файле, используйте
    * ключ компилятора `-o`, примерно так:
    *
    * `gcc <ваши опции> -o release.out lab2.cpp`
    */
#ifndef NDEBUG
  std::cout << "\n\nDebug version. 16.09.2024 lab2.cpp ex 2.5 str 345\n\n\n";
#endif

  /**
    * Задание 3.Заголовочные файлы. Директива #include.
    */

    /**
    * Задания 3.1.
    *
    * Создайте и подключите к проекту два заголовочных файла 1.h и 2.h.
    *
    * В каждом заголовочном файле объявите перечисление с одинаковыми именами
    * констант, но сопоставьте именованным константам разные значения,
    * например:
    *
    * - 1.h - enum MyEnum{My1, My2, My3};
    * - 2.h - enum MyEnum{My1=5, My2, My3};
    *
    * С помощью директив условной трансляции в DEBUG-версии пользуйтесь
    * значениями констант из 1.h, а в RELEASE-версии значениями констант из
    * 2.h.
    *
    * Замечание: заголовочные файлы принято подключать в верхней части файла,
    * до любых функций (хотя правила компиляции не запрещают подключить их
    * тут).
    */
  {
    std::cout << MyEnum::My1 + MyEnum::My2 + MyEnum::My3 << '\n';
    int x = 0;
  }

  /**
    * Задание 4. Указатели.
    */

    /**
    * Задание 4.1.
    *
    * Объявите объекты разных типов и проинициализируйте их.
    *
    * Объявите указатели соответствующих типов и проинициализируйте их
    * адресами заданных объектов.
    *
    * Выполняя задание, с помощью отладчика посмотрите, какие значения будут
    * присвоены переменным-указателям и на что эти указатели "указывают".
    */

  {

    int i = 0;
    float f = 1.5;
    char ch = 'A';

    int *px; // неинициализированная ссылка -> указывает в никуда

    int *pi = &i; 
    float *fi = &f;
    char *pch = &ch;

    // остальные ссылки указывают на мместо в памяти, где начинается хранение переменной

    int x = 0;
  }

  /**
   * Задание 4.2.
   *
   * Объявите указатель на тип char и проинициализируйте его адресом
   * строкового литерала. Присвойте переменной типа char значение любого
   * элемента строки.
   *
   * Проверьте - возможно ли присвоить какое-либо значение по адресу,
   * задаваемому указателем?
   */

  {
    // TODO: строковый литерал - это "abc"
    const char *pch = "abc"; // нельзя не const
    char ch = pch[1];

    // *pch = "bcd"; - нельзя; строковые литералы хранятся в спец блоке памяти, которая только для чтения, т.е. ее менять нельзя!!
  }

  /**
   * Задание 5. Арифметика указателей. Операция разыменования указателя.
   *
   * Выполните следующий код по строчкам в отладчике, проследите за
   * изменением значений указателей и значений объектов, на которые они
   * указывают.
   *
   * Интерпретируте наблюдаемые результаты.
   */
  {
    int nAr[3] = { 1,3 };
    int* pn = &nAr[0]; // указатель на 1 элемент массива
    (*pn)++; // увеличивает на 1 то, на что указывает pn, т.е. nAr[0]
    pn++; // смещает указатель pn на 1 в памяти, т.е. на nAr[1] (т.к. массив в памяти хранится последовательно)

    char cAr[] = { 'A', 'B', 'C', 'D' };
    char* pc = &cAr[0]; // указатель на первый элемент массива
    (*pc) = (*pc) + 5; // увеличивает символ, на который указывает pc на 5 (т.к. это char, то изменяется буква)
    pc = pc + 3; // сдвигает указатель по памяти на 3 вперед (т.е. на 'D')

    double dAr[3] = { 1.0,2.0 };
    double* pd1 = &dAr[0]; // указатель на 1 элемент массива
    double* pd2 = pd1; 
    (*pd2) += 2; // увеличивает значение, на которое ссылается указатель, на 2 -> изменяется массив и 2 ссылка на этот элемент
    pd2 += 2; // ссылка сдвигается на 2 вперед по памяти -> переходит на 3 элемент массива

    /** Объясните результат выполнения операции вычитания двух указателей */
    pd1 = &dAr[0];
    pd2 = &dAr[1];
    int nNumber = pd2 - pd1; // вычитание двух указателей показывает, сколько между ними элементов
                             // TODO: как происходит вычитание двух указателей? в арифметическом смысле

                             // Вычитание в 16 виде -> /8

    double ar3[3] = {1, 2, 3};
    double *x = &ar3[0];

    std::cout << pd1 << '\n' << pd2 << '\n' << (pd2 > pd1) << '\n';

    /**
     * Сравните указатели pd2 и pd1 и с помощью cout выведите результаты
     * сравнения.
     */
  }
  /*
      /**
       * Задание 6. Явное преобразование указателя.
       *
       * Иногда возникает необходимость одни и те же данные интерпретировать
       * по-разному, например, целое можно представить как совокупность четырех
       * байтов и работать с каждым байтом по отдельности. Для этого нужно иметь
       * возможность "указывать" как на целое, так и на байт.
       *
       * Следовательно, возникает необходимость явного преобразования указателя.
       *
       * Подсказка: для правильной интерпретации этого задания воспользуйтесь
       * возможностями отладчика представлять данные в интересующем Вас виде (в
       * данном случае - в шестнадцатеричном) - для этого можно использовать
       * команду print (p) с указанием шестнадцетиричного формата: `p/x`.
       */
  {
    unsigned int nObject = 0x55667788;
    unsigned int* pnObject = &nObject;
    unsigned char* pucObject;
    char cc;

    /**
     * Раскомментировав следующую строчку кода, обратите внимание на
     * сообщение компилятора - он не считает преобразование "легальным"
     * (безопасным)
     */
     // pucObject = static_cast<unsigned char*>(pnObject);
     // static_cast используется для преобразования различных указателей + для явного неявного преобразования
     // ругается т.к. "Типы, на которые указывают указатели, не связаны"

     /**
      * А такое преобразование - целиком на совести программиста. Его можно
      * применять, только четко представляя себе результат преобразования.
      */
    pucObject = reinterpret_cast<unsigned char*>(pnObject); // <=> pucObject = (unsigned char*)pnObject;
    // reinterpret_cast используется для приведения несовместимых типов
    // не ругается, т.к. reinterpret_cast не проверяет типы (действует как Си приведение)

    /** Проследите за значениями переменной `cc`. Объясните результаты. */
    cc = pucObject[0]; // '^' - 0x88
    cc = pucObject[1]; // 'w' - 0x77
    cc = pucObject[2]; // 'f' - 0x66
    cc = pucObject[3]; // 'U' - 0x55
    // числа в памяти хранятся с конца

    /**
     * Выполните следующие строки, наблюдая за значениями следующих
     * выражений: `cc`, `p` и `*p`.
     *
     * Зафиксируйте и интерпретируйте результаты.
     */
    cc = *(pucObject++); // берется объект по указателю pucObject = '^' -> pucObject сдвинулся на 1 по памяти
    cc = (*pucObject)++; // берется объект по указателю pucObject = 'w' -> pucObject увеличился на 1 = 'x'

    cc = ++ * (pucObject); // берется объект по указателю pucObject = 'x' -> увеличивает ее на один -> присваивает в cc
    cc = *(++pucObject); // pucObject сдвигается на 1 -> берется объект по указателю pucObject = 'f'
  }

  /**
   * Задание 7. Void-указатель.
   */

   /**
    * Задание 7.1.
    *
    * Выполняя задание, посмотрите - какие значения присваиваются
    * void-указателю.
    *
    * Обратите внимание: средствами отладчика вы не можете посмотреть
    * значения, на которые "указывает" void-указатель.
    */
  {
    void* pVoid;
    int nObject3 = 5;
    char cObject3 = 'A';
    int* pInt = &nObject3;
    pVoid = &nObject3;
    pVoid = &cObject3;
    pVoid = pInt;

    /**
     * Прежде, чем раскомментировать следующую строчку, вспомните: что
     * нужно сделать, чтобы выражение стало корректным?
     */
     pInt = reinterpret_cast<int *>(pVoid);
  }

  /**
   * Что нужно сделать для того, чтобы следующее закомментированное выражение
   * стало корректным?
   *
   * В закоментированной строке необходимо объявить void-указатель.
   */
  {
    const int n = 1;
    const void *pn = &n;
  }

  /**
   * Задание 7.2.
   *
   * При выполнении следующего фрагмента посмотрите, какие неприятности могут
   * Вас ожидать при явном приведении типа void-указателя, который в момент
   * времени (1) указывает на double, к типу указателя на int (2).
   */

  {
    double dObject3 = 33.33;
    void *pVoid = &dObject3;  //(1) не отображается, на какое значение указывает pVoid

    double p1 = *(static_cast<double *>(pVoid));

    int nTmp = *(static_cast<int*>(pVoid) ); //(2) данные похерились
  }

  /**
   * Задание 8. Модификатор const.
   */

   /**
    * Задание 8.1.
    *
    * В каждом из заданий объявите указатель требуемого вида.
    *
    * Посредством каждого указателя попробуйте:
    *
    * - получить значение по адресу;
    * - записать новое значение по адресу;
    * - модифицировать указатель.
    */

    /**
     * Задание 8.1.1. Указатель является константой.
     */

  {
    int i = 5;
    int * const pi = &i;

    std::cout << "ex 8.1.1 " << *pi << '\n';
    *pi = 6;
    // pi++; - нельзя, т.к. указатель - константа
  }

  /**
   * Задание 8.1.2. Указываемое значение является константой.
   */

  {
    int i = 5;
    const int *pi = &i;

    std::cout << "ex 8.1.2 " << *pi << '\n';
    // *pi = 6; нельзя сделать, т.к. указатель на константу, при этом i = 6
    pi++;
  }

  /**
   * Задание 8.1.3. И указатель, и указываемое значение являются константами.
   */
  {
    int i = 5;
    const int * const pi = &i;

    std::cout << "ex 8.1.3 " << *pi << '\n';
    // *pi = 6; нельзя сделать, т.к. const int * - указатель на константу
    // pi++; нельзя сделать, т.к. указатель константа
  }

  /**
   * Задание 8.2. Указатель на переменную, объявленную с ключевым словом
   * const.
   *
   * Объявите указатель и проинициализируйте его выражением - `&nN`.
   */

  {
    // const int n = 1;
    // ... = &n;

    const int nN = 1;
    const int *pnN = &nN;
  }

  /**
   * Задание 9. Указатели на указатели.
   */

  {
    int n = 1;

    /**
     * Объявите указатель pn и проинициализируйте его так, чтобы он
     * "указывал" на n.
     */
    int *pn = &n;

     /**
      * Объявите указатель ppn и проинициализируйте его так, чтобы он
      * "указывал" на pn.
      */
    int **ppn = &pn;

      /**
       * Объявите указатель pppn и проинициализируйте его так, чтобы он
       * "указывал" на ppn.
       */
    int ***pppn = &ppn;

       /**
        * С помощью указателей pn, ppn и pppn получите значение объекта n и
        * присвойте его m.
        */

    int m = *pn;
    m = **ppn;
    m = ***pppn;
  }
  return 0;
}
 
/**
 * Практическое занятие №1. Базовые типы данных, операторы языка, простой
 * ввод-вывод.
 *
 * В результате выполнения данной работы слушатель получает много мелких, но
 * необходимых для дальнейшей работы навыков, поэтому задание построено как
 * последовательность закомментированных блоков, которые требуется
 * последовательно раскомментировать, отвечая при этом на поставленные вопросы.
 *
 * Необходимое программное обеспечение:
 *
 * - Unix-совместимая командная строка (для Windows необходимо установить WSL);
 * - компилятор g++, отладчик gdb (для установки в командной строке:
 *   `apt update; apt install gcc g++ gdb`)
 * - любимый текстовый редактор.
 *
 * Примерная последовательность действий при отладке проекта:
 * 1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст
 *    программы;
 * 2. скомпилируйте программу (в командной строке: `g++ -g lab1.cpp`);
 * 3. запустите отладчик (в командной строке `gdb ./a.out`);
 * 4. в отладчике установите точку останова на нужной строке (например,
 *    `break 55` для 55 строки или `b 55` - так короче) и начните выполнение
 *    программы (`run` или `r`).
 * 5. выведите значение интересующей переменной (`print cByte` или `p cByte`)
 *    или добавьте переменную для постоянного отслеживания (`watch cByte`).
 * 6. Переходите к следующей точке останова (`c`) или к следующей строке (`n`).
 */

#include  <iostream>


int nTwin = 1;
namespace TwinSpace { int nTwin = 2; }

int main()
{
  /**
   * Задание 1. Работа с отладчиком. Базовые типы данных. Литералы.
   *
   * Выполняя программу по шагам, следите за значениями переменных и
   * интерпретируйте результат (помните, что количество байт, отводимых под
   * int, системо-зависимо).
   *
   * Обратите внимание на разную интерпретацию отладчиком signed и unsigned
   * целых типов данных, а также на внутреннее представление отрицательных
   * целых чисел.
   */

  char cByte = 'A';
  cByte = 0x42;
  cByte = 66;
  cByte = -1;

  unsigned char ucByte = 0x41;
  ucByte = 'B';
  ucByte = -1;

  int iInt = 0xffffffff;

  unsigned int uiInt = 0xffffffff;

  float fFloat = 1.f;
  double dDouble = 1.;

  /**
   * Выполните фрагмент, приведенный далее. В комментариях отразите, что
   * реально заносится в переменную. Объясните разницу между этим значением и
   * инициализатором.
   */

  double d = 0.1234567890123456789123456789;
  // d =  0.12345678901234568, меньше знаков после запятой
  float  f = 0.1234567890123456789123456789;
  // f = 0.123456791, меньше знаков после запятой

  d = 1.;
  // d = 1.0000000000000000, после запятой ничего не стоит, это приравнивается к 0
  d = 0.999999999999999999999999999999999;
  // d = 1, слишком большая точность, не помещается в double, поэтому округление

  /**
   * В комментариях напишите результат, возвращаемый оператором sizeof для
   * переменной типа wchar_t (ее размер)
   */

  wchar_t cw = L'Ф';
  size_t n = sizeof(cw);
  // n = 2;

  /**
   * Задание 2a. Неявное приведение типов данных.
   *
   * Объясните разницу результата при выполнении (1) и (2): Покажите явно
   * (напишите в коде) преобразования, которые неявно выполняет компилятор
   */

  iInt = 1;
  double dDouble1 = iInt / 3;     // (1)
  // double dDouble1 = int(iInt / int(3));
  double dDouble2 = iInt / 3.;    // (2)
  // double dDouble2 = double(iInt) / double(3.);

  /**
   * Ассоциативность операторов.
   *
   * Синтаксис языка C допускает "цепочечное" присваивание (как в строках (1)
   * и (2)). Посмотрев результаты выполнения строк (1) и (2) (значения
   * переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок
   * выполнения присваиваний при цепочечной записи и объясните результат.
   *
   * Расставьте скобки, явно определяющие порядок выполнения, как это сделал
   * бы компилятор. Объясните (в комментариях) предупреждения (warnings)
   * компилятора.
   */

  short sShort;
  dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3; // (1)
  // dDouble = (fFloat = (iInt = (sShort = (cByte = (3.3 / 3)))));
  // преобразование "double" в "char", возможна потеря данных -> 3.3 / 3 - double, пытаемся записать в char (8 байт под double, 1 байт под char)
  // преобразование "int" в "float", возможна потеря данных -> тк под int выделяется 32 бита, а под float 32 бита с учетом экспоненты, то float имеет меньшую точность

  cByte = sShort = iInt = fFloat = dDouble = 3.3 / 3; // (2)
  // cByte = (sShort = (iInt = (fFloat = (dDouble = (3.3 / 3)))));
  // преобразование "double" в "float", возможна потеря данных -> во float пытаемся записать double (double 8 байт, float 4 байт)
  // преобразование "float" в "int", возможна потеря данных -> в float хранятся знаки после запятой, в int нет
  // преобразование "short" в "char", возможна потеря данных -> short 2 байт, char 1 байт

  /**
   * Ниже Вам дан пример "небрежного" использования неявного приведения
   * типов, что может привести к нежелательным результатам - объясните (в
   * комментариях), к каким?
   *
   * Напишите явно преобразования, которые неявно выполняет компилятор.
   */

  iInt = 257;
  cByte = iInt; // cByte = char(257), char хранит от -128 до 127 -> переполнение -> cByte = 1

  unsigned char cN1 = 255, cN2 = 2, cSum;
  cSum = cN1 + cN2; // cSum = 255 + 2 -> cSum = 257 -> Переполнение uchar -> cByte = 1

  /**
   * Сравните предыдущую строчку с приведенной ниже.
   *
   * Объясните (в комментариях), почему в следующей строке не происходит
   * выход за разрядную сетку
   *
   * Напишите явно преобразования, которые неявно выполняет компилятор
   */

  int iSum = cN1 + cN2; // int iSum = int(cN1) + int(cN2) = 255 + 2 = 257 (в int можно хранить большие значения)

  /**
   * Напишите, почему при сложении одинаковых значений (одинаковых в двоичной
   * системе) в строках (1) и (2) получаются разные результаты.
   *
   * Напишите явно преобразования, которые неявно выполняет компилятор и
   * объясните, что при этом происходит.
   */

  char c1 = 0xff, c2 = 2;
  unsigned char uc1 = 0xff, uc2 = 2;
  int iSum1 = c1 + c2;   //(1)
  int iSum2 = uc1 + uc2; //(2)

  // char c1 = 0xff -> переполнение char -> c1 = -1; c2 = 2
  // unsigned char uc1 = 0xff = 255; uc2 = 2
  // int iSum1 = c1 + c2 = -1 + 2 = 1
  // int iSum2 = uc1 + uc2 = 255 + 2 = 257;


  /**
   * Задание 2b. Явное приведение типов данных.
   *
   * Проинтерпретируйте результат (значения переменной dDouble) в строке (3).
   *
   * Напишите явно преобразования, которые неявно выполняет компилятор.
   */

  int nTmp = 100, nn = 3;
  dDouble = 3.3 + nTmp / nn; // (3)
  // dDouble = 3.3 + int(nTmp) / int(nn) = 3.3 + 33 = 36.299999999999997

  /**
   * Получите результат без потери точности с помощью оператора явного
   * приведения типа.
   */

   // double dDouble3 = ...     // (4)
  double dDouble3 = 3.3 + nTmp / double(nn);
  
  /**
   * Задание 3. Область действия, область видимости и время существования
   * переменных.
   *
   * В этом фрагменте фигурируют четыре переменных с одним и тем же именем
   * nTwin - одна глобальная, вторая определена в своем пространстве имен,
   * (определены выше в начале модуля) третья - локальная внутри функции
   * main(), четвертая - вложенная локальная внутри блока.
   *
   * В данном задании требуется в выделенных местах фрагмента определить, к
   * какой из четырех переменных идет обращение, а также факт существования и
   * видимости для всех четырех, заполнив приведенные в задании таблицы.
   *
   * Для выведения информации в отладчике можно воспользоваться командой
   * `info locals`, которая выведет локальные переменные в функции main(),
   * и командой `watch nTwin` или `wacth ::nTwin` для отслеживания значений
   * переменных.
   */

  nTwin = 100; // global nTwin
  TwinSpace::nTwin = 300; // namespace nTwin
  nTwin++; // global nTwin = 101

  int nTwin;
  nTwin = 200;  // main nTwin
  ::nTwin++;  // global nTwin
  {
    // TODO: как разрешается имя, если такая переменная не определена в блоке?
    // ищет переменную в блоке выше (т.е. в данном случае в функции)
    int nTwin;
    nTwin = -1; // local nTwin
    ::nTwin++;  // global nTwin
    TwinSpace::nTwin++;  // namespace nTwin
  }

  nTwin--; // main nTwin


  /**
   * Задание 4. Спецификатор класса памяти - static.
   *
   * 1. Для каждой итерации цикла напишите значения пременных nLocal# и
   *    nStatic#.
   * 2. Напишите, когда выполняется инициализация обеих переменных.
   * 3. Поясните (в комментарии) разницу между способом инициализации
   *    переменных nStatic1 и nStatic2 и поясните побочный эффект, влияющий
   *    на переменную nLocal2.
   */

  for (int i = 0; i < 3; i++)
  {
    static int nStatic1 = 100;
    int nLocal1 = 100;
    int nLocal2 = 200;
    static int nStatic2 = nLocal2++ * 2;
    nStatic1++;
    nStatic2++;
    nLocal1++;
  }

  /* 1: nStatic1 = 100 -> nLocal1 = 100 -> nLocal2 = 200 -> nStatic2 = 400 ->
        -> nLocal2 = 201 -> nStatic1 = 101 -> nStatic2 = 401 -> nLocal1 = 101 */
  /* 2: nStatic1 = 101 (не создавалась заново) -> nLocal1 = 100 -> nLocal2 = 200 ->
        -> nStatic2 = 401 (не создавалась заново) -> nStatic1 = 102 -> nStatic2 = 402 -> nLocal1 = 101 */
  /* 3: nStatic1 = 102 (не создавалась заново) -> nLocal1 = 100 -> nLocal2 = 200 ->
        -> nStatic2 = 402 (не создавалась заново) -> nStatic1 = 103 -> nStatic2 = 403 -> nLocal1 = 101 */

  /* Инициализация переменных nStatic1 и nStatic2 происходит при первом круге цикла.
      Разница в том, что 1 инициализируется числом, вторая через переменную. nLocal2 изменяется после того,
      как инициализируется nStatic2 */


  /**
  * Напишите:
  * 1. как изменилось поведение пременной nStatic1?
  * 2. как эта переменная _инициализирована_?
  */

  for (int i = 0; i < 3; i++)
  {
    // TODO: какое значение примет неинициализированная а) автоматическая переменная, 
    // б) статическая переменная?

    // static -> 0
    // не static инициализируется мусором (рандомным куском памяти)

    static int nStatic1;
    nStatic1 = 100;
    int nLocal1 = 100;
    nStatic1++;
    nLocal1++;
  }

  /* nStatic1 всегда 100 -> 101; эта переменная создается 1 раз для цикла (не инициализирована),
     потом она заново переприсваевается.*/

  /**
   * Задание 5. Перечисления - enum.
   *
   * Обратите внимание на явную и неявную инициализацию констант.
   *
   * Выполняя задание по шагам, следите за значениями, которые принимает
   * переменная myColors.
   */

  enum eColors
  {
    BLACK,
    BLUE,
    GREEN,
    RED = 5,
    YELLOW,
    WHITE = RED + 4
  };

  eColors myColors;  //объявление переменной типа eColors 
  myColors = BLACK;  // 0
  myColors = BLUE;   // 1
  myColors = GREEN;  // 2
  myColors = RED;    // 5
  myColors = YELLOW; // 6
  myColors = WHITE;  // 9

  int nnn = BLACK; //любой целочисленной переменной можно присвоить
  //значение из списка инициализирующих значений

  //Именованные константы можно использовать в выражениях:
  nnn = BLUE | YELLOW; // 7 = BLACK + YELLOW

  /**
   * Раскомментируйте следующую строку и обратите внимание на ошибку при
   * компиляции.
   *
   * Модифицируйте выражение таким образом, чтобы компилятор не выдывал
   * ошибки.
   */

  myColors = eColors(1); 

  /**
   * Выполните следующее присваивание НЕ меняя перечисление и тип переменной
   * myColors.
   */

  myColors = eColors(123);


  /**
   * Задание 6.1 Логический тип bool.
   *
   * Выполняя задание по шагам, следите за значениями переменной b и
   * интерпретируйте результат.
   *
   * Напишите эти значения в комментариях.
   */

  int nNumber = 1;
  bool b = (nNumber != 0); // true
  b = (nNumber == 0); // false
  b = (nNumber > 0); // true
  b = (nNumber > 1); // false
  b = 5; // true

  /**
   * Вы всегда можете преобразовать логическое значение к целому явно или
   * компилятор может это сделать самостоятельно (неявно).
   *
   * Обратите внимание: как интерпретирует значения логических переменных
   * компилятор?
   */

  int tmp = b + 1; // tmp = int(true) + 1 = 1 + 1 = 2

  /**
   * Задание 6.2.
   *
   * В Григорианском календаре (которым мы все пользуемся) високосный год
   * определяется по следующему алгоритму: високосным является каждый
   * четвертый год, но каждый сотый високосным не является, при этом каждый
   * 400-й год все таки високосный. Т.е. 1823 - не високосный, 1824 -
   * високосный, 1900 - не високосный, 2000 - високосный.
   *
   * Напишите фрагмент кода, такой что логическая переменная isLeapYear
   * принимает значение true, если год, заданный переменной year -
   * високосный. Проверьте значение в отладчике.
   *
   * Указание: в этом задании нельзя использовать операторы if-else, switch и
   * тернарный оператор; необходимо написать логическое выражение в одну
   * строку.
   */

  {
    int year = 1823;
    year = 1824;
    year = 1900;
    year = 2000;

    bool isLeapYear = ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)));
  }

  /**
   * Задание 7. Модификатор const и переменные.
   *
   * Раскомментируйте следующие две строчки и объясните (в комментариях)
   * ошибки при компиляции.
   */

  {
    // const int nN; // объект const необходимо инициализировать, если он не внешний (extern) -> константа инициализируется только при создании
    // nN = 1; // невозможно присваивать значения переменной, которая объявлена как константа -> константа инициализируется только при создании
  }

  /**
   * Задание 8. Потоки ввода и вывода C++.
   *
   * Напишите фрагмент кода, который бы с помощью объектов потока std::cin и
   * std::cout делал бы следующее:
   *
   * 1. Выводил бы на экран номер задания.
   * 2. Считывал целое число.
   * 3. Считывал символ.
   * 4. Выводил пользователю введенный им символ.
   * 5. Выводил пользователю введенное им целое число.
   *
   * При этом добавьте в места, где от пользователя ожидается ввод,
   * соответствующие приглашения ко вводу (например, `Введите целое число: `).
   */

  
  {
    int inputInt;
    char inputChar;

    std::cout << "Task number: 8\n";
    std::cout << "Input an integer: ";
    std::cin >> inputInt;
    std::cout << "Input a char: ";
    std::cin >> inputChar;
    std::cout << "The entered char: " << inputChar << '\n';
    std::cout << "The entered integer: " << inputInt << '\n';

  }
  

  /**
   * Задание 9. Логические условные операторы и операторы отношения.
   */

   /**
    * Задание 9.1.
    *
    * Напишите фрагмент кода, который переводит код символа, хранящийся в
    * переменной ch в противоположный регистр.
    *
    * Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
    * или нажал другую клавишу, которой символ не соответствует.
    *
    * Подсказка: работаем только с символами английского алфавита, для
    * которого в таблице кодов ASCII код каждой буквы нижнего регистра на 0x20
    * больше кода соответствующей буквы верхнего регистра.
    */

  
  {
    const int REGISTER_SHIFT = 0x20; // 
    char ch;
    // Тут сформируйте значение переменной ch с помощью потока ввода.
    std::cout << "Input a char: ";
    std::cin >> ch;

    if (ch >= 'A' && ch <= 'Z') {    // TODO: избавиться от "магических чисел"
      // Тут измените регистр.
      ch = ch + REGISTER_SHIFT;
      // Тут вывели получившийся символ пользователю.
      std::cout << ch << '\n';
    }
    else if (ch >= 'a' && ch <= 'z') {
      ch = ch - REGISTER_SHIFT;
      std::cout << ch << '\n';
    }
    else
      std::cout << "It isn't a char\n";

  }
  
  /**
   * Задание 9.2.
   *
   * Напишите фрагмент кода, который реализует с помощью if (if/else)
   * следующую логику: если x меньше или равен 0, y=0, если x больше 0 но
   * меньше 1, то y=x, если x больше или равен 1, то y=1.
   *
   * Подумайте: какого типа должны или могут быть x и y?
   */

  
  {
    double x, y;

    std::cout << "Enter x: ";
    std::cin >> x;

    if (x <= 0)
      y = 0;
    else if (x > 0 && x < 1)
      y = x;
    else if (x >= 1)
      y = 1;

    std::cout << "y = " << y << '\n';

  }
  
  /**
   * Задание 9.3
   *
   * Напишите фрагмент кода, который реализует с помощью switch следующую
   * логику: в переменной cInput типа char дано значение символа, введенного
   * любым способом.
   *
   * Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
   * переменной у значение переменной x.
   *
   * Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
   * переменной у значение (x * 2).
   *
   * Если любой другой симол, то вывести сообщение об ошибке.
   */

  
  {
    char ch;
    double x, y = 0;

    std::cout << "Enter x: ";
    std::cin >> x;

    std::cout << "Print y/n: ";
    std::cin >> ch;

    switch (ch)
    {
    case 'y':
    case 'Y':
      y = x;
      break;
    case 'n':
    case 'N':
      y = x * 2;
      break;
    default:
      std::cout << "Uncorrect symbol\n";
    }

    std::cout << "y = " << y << '\n';
  }
  

  /**
   * Задание 10. Циклы.
   */

   /**
    * Задание 10.1.
    *
    * Напишите фрагмент кода, который реализует с помощью for следующую
    * логику: найти сумму заданного диапазона целых чисел.
    *
    * Введите границы с помощью потока ввода или с помощью средств отладки.
    *
    * Предусмотрите защиту от ввода нижней границы больше, чем верхней.
    */

  
  {
    int beg, end;

    // сформироыать границы диапазона
    std::cout << "Enter begin number: ";
    std::cin >> beg;
    std::cout << "Enter end number: ";
    std::cin >> end;

    // проверить корректность значений
    if (beg < end)
    {
      // вычислить сумму
      int sum = 0;
      for (int i = beg; i <= end; i++)
        sum += i;

      // проверить в отладчике значение
      std::cout << "Sum = " << sum << '\n';
    }
    else
      std::cout << "Error: begin > end!\n";
  }
  
  /**
   * Задание 10.2.
   *
   * Напишите фрагмент кода, который реализует с помощью do-while следующую
   * логику: на каждой итерации цикла ввести с консоли целое значение и
   * покинуть цикл, если значение удовлетворяет условию: значение больше или
   * равно 10 и четное.
   */
  
  {
    int x = 0;

    do
    {
      std::cout << "Enter an integer: ";
      std::cin >> x;
    } while (x < 10 || x % 2 != 0);

  }
  
  /**
   * Задание 10.3.
   *
   * Напишите фрагмент кода, который реализует с помощью while следующую логику:
   *
   * 1. исходно int x = 0;
   * 2. на каждой итерации x = x + 1, sum = sum + 1 / x;
   * 3. необходимо найти значение x, при котором sum > 1.7.
   */
  
  {
    int x = 0;
    double sum = 0;

    while (sum <= 1.7)
    {
      x = x + 1;
      sum = sum + 1 / x;   // TODO: что будет, если оставить так?
      // произойдет exception (деление на 0), т.к. x удет бесконечно увеличиваться, выйдет за рязрядную сетку, и дойдет до 0
    }

    std::cout << "X: " << x << " sum: " << sum << '\n';

  }
  
  /**
   * Задание 10.4.
   *
   * Раскомментируйте следующий блок кода, который считает сумму 10
   * последовательных натуральных чисел, начиная со 120.
   *
   * Объясните логические ошибки в нем и исправьте их.
   */

  {
    /*
    char start = 120, sum = 0;
    for (char n = start; n < start + 10; ++n)
    {
       sum += n;
    }

    std::cout << sum;
    */
    // ошибка в том, что все переменные типа char.

    int start = 120, sum = 0;
    for (int n = start; n < start + 10; ++n)
    {
      sum += n;
    }

    std::cout << sum;
  }

  return 0; /** код завершения приложения */
}

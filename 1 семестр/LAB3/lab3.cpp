/**
 * Практическое занятие №3. Встроенные массивы. Динамическое выделение памяти.
 * Простейшие алгоритмы сортировки и поиска. Сложные указатели.
 */

#include <string>
#include <iostream>
#include <cstdio>
#include <ctime>

int main()
{
#if 0
  /**
     * Задание 1. Встроенные массивы.
     */

    /**
     * Задание 1.1.
     *
     * Объявите трехмерный N*M*K массив и сформируйте значения
     * элементов, указанные на иллюстрации ниже, с помощью инициализации при
     * объявлении.
     *
     *                   |--------|     
     *                 / |3  3  3 |     
     *               |---------|3 |
     *             / | 2  2  2 |3 |
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__| 
     *            | 1  1  1 | /
     *            |_________|
     */

  int A[3][3][3] = {
    {
      {1, 1, 1},
      {1, 1, 1},
      {1, 1, 1}
    },
    {
      {2, 2, 2},
      {2, 2, 2},
      {2, 2, 2}
    },
    {
      {3, 3, 3},
      {3, 3, 3},
      {3, 3, 3}
    }
  };

    /**
     * Задание 1.2.
     *
     * Объявите неинициализированный массив и присвойте значения элементам с
     * помощью кода так, чтобы в итоге получился такой же массив, как в задании
     * 1.1.
     */

  int A1[3][3][3];

  /* [глубина][строка][столбец] */

  for (int d = 0; d < 3; d++)
    for (int y = 0; y < 3; y++)
      for (int x = 0; x < 3; x++)
        A1[d][y][x] = d + 1;

    /**
     * Задание 1.3.
     *
     * Напишите код, с помощью которого можно найти сумму элементов массива,
     * полученного в задании 1.
     */

  int sum1 = 0;

  for (int d = 0; d < 3; d++)
    for (int y = 0; y < 3; y++)
      for (int x = 0; x < 3; x++)
        sum1 += A[d][y][x];

  std::cout << "1.3: sum = " << sum1 << '\n';

    /**
     * Задание 1.4.
     *
     * Проинициализируйте массив при объявлении следующим образом:
     *
     *                   |--------|     
     *                 / |3  0  0 |     
     *               |---------|0 |
     *             / | 2  0  0 |0 |
     *            |---------|0 |__|
     *            | 1  0  0 |0 | /
     *            | 0  0  0 |__| 
     *            | 0  0  0 | /
     *            |_________|
     *
     * Как это можно сделать наиболее коротким (в смысле количества кода)
     * образом?
     */

  int A2[3][3][3] {{1}, {2}, {3}};

  // TODO: можно короче
    /**
     * Задание 1.5. Инициализация массивов строковыми литералами.
     * 
     * Объявите и проинициализируйте строковыми литералами два массива:
     * двухмерный массив и массив указателей. Поясните разницу в использовании
     * элементов таких массивов.
     */

  char C1[2][3] = {"AB", "CD"};
  // <массив указателей> C2 = {"AB", "CD"}; // TODO: сделать в такой форме
  const char *C2[2] = {"ABababab", "CD"};

  // В массиве указателей можно хранить строки различных размеров без указания максимального размера

  //  чтобы достать указатель на элемент с индексом [j][i] нужно взять элемент [j * W + i]
    /**
     * Задание 2. Динамическое выделение памяти.
     */

    /**
     * Задание 2.1.
     *
     * Создайте динамический двухмерный массив с размерностями, вычисляемыми в
     * процессе выполнения программы - N*M, эти размерности можно сформировать
     * случайно в некотором диапазоне или ввести с консоли.
     *
     * Задайте значения элементов помощью генератора случайных чисел. 
     *
     * Найдите сумму элементов.
     *
     * Подсказка 1: для генерации случайных чисел используйте функцию
     * стандартной библиотеки - rand() (<cstdlib>).
     *
     * Подсказка 2: На самом деле те значения, которые создаются генератором
     * случайных чисел являются «псевдослучайными», то есть при двух
     * последовательных запусках приложения Вы получаете две одинаковые
     * последовательности значений.
     *
     * Для того чтобы генерируемые "случайные" значения были разными при каждом
     * запуске приложения используйте функции стандартной библиотеки srand()
     * (<cstdlib>) и time() (<ctime>).
     *
     * Функция srand() осуществляет «привязку» начала генерации к указанному в
     * качестве параметра значению.
     *
     * Функция time() задает эту точку отсчета, считывая текущее время.
     */

  int N, M;

  std::cout << "2.1:\n" << "Input N: ";
  std::cin >> N;
  std::cout << "Input M: ";
  std::cin >> M;

  int **B = new int *[N], sum2 = 0;

  srand((int)time(0));

  for (int i = 0; i < N; i++)
  {
    B[i] = new int[M];

    for (int j = 0; j < M; j++)
      B[i][j] = rand(), sum2 += B[i][j];
  }

  std::cout << sum2 << '\n';

  /**
     * Задание 2.2.
     *
     * В сформированном массиве отсортируйте каждую строку по убыванию
     * значений. Используйте сортировку "выбором".
     */

  for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
    {
      int max_ind = j, tmp;

      for (int k = j + 1; k < M; k++)
        if (B[i][k] > B[i][max_ind])
          max_ind = k;

      tmp = B[i][j], B[i][j] = B[i][max_ind], B[i][max_ind] = tmp;
    }

    /**
     * Задание 2.3.
     *
     * Объявите одномерный массив размерностью N. 
     *
     * Сформируйте значение i-ого элемента одномерного массива равным среднему
     * значению элементов i-ой строки двухмерного массива.
     */

  int *B2 = new int[N];

  for (int i = 0; i < N; i++)
  {
    B2[i] = 0;
    for (int j = 0; j < M; j++)
      B2[i] += B[i][j];
    B2[i] /= M;
  }

    /**
     * Задание 2.4. 
     *
     * Убедитесь, что вся выделенная память очищена.
     *
     * Чтобы убедиться в этом, скомпилируйте программу с включенной проверкой
     * утечек памяти - с ключом `-fsanitize=address`:
     *
     * `gcc <ваши обычные флаги> -fsanitize=address lab3.cpp`
     *
     * Если после выполнении программы выдаются сообщения об утечках, это
     * означает, что где-то не удалена выделенная память.
     */
  

  for (int i = 0; i < N; i++)
    delete[] B[i];

  delete[] B;
  
  delete[] B2;

  /**
     * Задание 3.
     */

    /**
     * Задание 3.1. Онлайн-упорядочивание.
     *
     * Напишите фрагмент кода, который вводит N целых чисел с помощью потока
     * ввода в объявленный Вами встроенный одномерный массив, каждый раз
     * упорядочивая полученное значение по возрастанию.
     *
     * Дайте оценку количества сравнений и перестановок при вводе всех чисел
     * относительно N.
     *
     * Постарайтесь, чтобы и сравнений, и перестановок было не больше, чем
     * k*N^2, где k - некоторое число.
     */

  {
    int N, *A;

    std::cout << "3.1\n" << "Input N: ";
    std::cin >> N;
    std::cout << "Input n integers:\n";

    A = new int[N] {};

    for (int i = 0; i < N; i++)
    {
      int x, j = 0;

      std::cin >> x;

      while (j < i && x > A[j])
        j++;

      for (int k = i; k > j; k--)
        A[k] = A[k - 1];

      A[j] = x;
    }

    delete[] A;
    // Сравнений < N^2, перестановок < N^2
  }

    /**
     * Задание 3.2. Простой поиск.
     *
     * Модифицируйте предыдущее задание следующим образом: очередное значение
     * вводится в массив только при условии, что там еще такого нет (то есть
     * дубли игнорируются).
     */
  {
    int N, *A;

    std::cout << "3.2\n" << "Input N: ";
    std::cin >> N;
    std::cout << "Input n integers:\n";

    A = new int[N] {};

    for (int i = 0; i < N; i++)
    {
      int x, j = 0, flag = 1;

      std::cin >> x;

      for (int k = 0; k < i; k++)
        if (x == A[k])
          flag = 0;

      if (!flag) continue;
      while (j < i && x > A[j])
        j++;

      for (int k = i; k > j; k--)
        A[k] = A[k - 1];

      A[j] = x;
    }

    delete[] A;
  }

    /**
     * Задание 4. Сортировка строк.
     *
     * С помощью данной заготовки напишите программу, которая:
     *
     * 1. вводит строки с клавиатуры с помощью cin>>... в объявленный Вами
     *    двухмерный встроенный массив 5*80 элементов типа char; признаком конца
     *    ввода является символ * (то есть строка - "*") или заполнение массива
     *    (больше свободных строк нет);
     * 2. сортирует строки в алфовитном порядке и выводит на экран.
     *
     * Пояснение: крайне не рекомендуется для сортировки сложных объектов
     * физически перемещать их в памяти. Намного эффективнее завести массив
     * указателей на соответствующие строки и перемещать только указатели.
     *
     * Подсказка: для лексиграфического сравнения строк пользуйтесь функцией
     * стандартной библиотеки strcmp(...), заголовочный файл <string>.
     */
  {
    /** Определите необходимые значения как константы */
    const int N = 5, M = 80;
    int max_size = 0;
    const char STOP_CHAR[2] = "*";

    /** 
     * Объявите двухмерный массив с именем cBuffer типа char и размерностью
     * N*M.
     */
    char cBuffer[N][M] {};

    /**
     * Объявите массив (с именем cPointers) указателей на строки
     * размерностью N.
     */
    char *cPointer[N] {};

    /** 
     * Цикл ввода строк:
     * 1. выведите приглашение для ввода; 
     * 2. пока не введена строка STOP_STRING или не заполнен весь массив; 
     */

    std::cout << "4.\n";

    for (int i = 0; i < N; i++)
    {
      std::cout << "Input string:\n";

      /** ввод строки в массив cBuffer: */
      std::cin >> cBuffer[i];

      /** если введена строка - признак окончания, то выйти из цикла */
      if (strcmp(cBuffer[i], STOP_CHAR) == 0)
        break;
      /** Присвойте элементу массива cPointers с индексом nIndex */
      /** указатель на строку с номером nIndex в массиве cBuffer */
      cPointer[i] = cBuffer[i];
      max_size++;
    }

    /** Выдать диагностику о том, что прием строк завершен.*/
    std::cout << "All strings were entered\n";

    /**
     * Теперь сортируем строки.
     *
     * Необходимо использовать сортировку строк по методу "всплывающего
     * пузырька" в порядке возрастания. 
     *
     * На каждой итерации - промежуточная печать отсортированных строк.
     */

    char *tmp;

    for (int i = 0; i < max_size; i++)
    {
      int flag = 1;

      for (int j = 0; j < max_size - i - 1; j++)
        if (strcmp(cPointer[j], cPointer[j + 1]) == 1)
          tmp = cPointer[j], cPointer[j] = cPointer[j + 1], cPointer[j + 1] = tmp, flag = 0;

      if (flag)
        break;

      std::cout << i << " iteration\n";
      for (int j = 0; j < max_size; j++)
        std::cout << cPointer[j] << '\n';
    }

  }

/*
    /**
     * Задание 5. Динамические строки.
     *
     * Реализуйте задание №4, используя не встроенные, а динамические массивы
     * (массив?). Так как строки могут быть разной длины, эффективным решением
     * было бы отводить под каждую строку ровно столько байтов, сколько
     * требуется для ее хранения.
     *
     * Реализуйте это задание так, чтобы пользователь мог ввести строку любой
     * длины (которая помещается в память компьютера - читайте: неограниченной
     * длины).
     *
     * При этом необходимые параметры (количество строк) сформируйте с помощью
     * потока ввода.
     */
  {
    const char STOP_CHAR[2] = "*";
    char **cBuffer;
    // std::string **cPointer;
    int N;

    std::cout << "5.\n" << "Enter N: ";
    std::cin >> N;

    cBuffer = new char * [N];
    // cPointer = new std::string * [N];

    for (int i = 0; i < N; i++)
    {
      std::string str;

      std::cout << "Input string:\n";
      std::cin >> str;

      cBuffer[i] = new char[str.size()] {};
      strcpy(cBuffer[i], str.c_str());
    }

    char *tmp;

    for (int i = 0; i < N; i++)
    {
      int flag = 1;

      for (int j = 0; j < N - i - 1; j++)
        if (strcmp(cBuffer[j], cBuffer[j + 1]) == 1)
          tmp = cBuffer[j], cBuffer[j] = cBuffer[j + 1], cBuffer[j + 1] = tmp, flag = 0;

      if (flag)
        break;

      std::cout << i << " iteration\n";
      for (int j = 0; j < N; j++)
        std::cout << cBuffer[j] << '\n';
    }

    for (int i = 0; i < N; i++)
      delete[] cBuffer[i];
    delete[] cBuffer;
  }
#endif
    /** 
     * Задание 6. Работа со строками.
     *
     * Реализуйте следующую программу. Пользователь вводит строку (любого
     * размера), после чего пользователю выводится на консоль следующее
     * изображение, где его ввод помещен в "speech bubble":
     *
     *  _____________________________________
     * / Here user input is shown. This line \
     * \ must be at most 40 characters long. /
     *  ------------------------------------
     *     \
     *      \
     *        /\_/\  (
     *       ( ^.^ ) _)
     *         \"/  (
     *       ( | | )
     *      (__d b__)
     *
     *  При этом длина строки в "облачке" должна быть не более 40 символов, при
     *  этом слова должны переноситься аккуратно. Это означет, что не должно
     *  быть переносов в центре слова (если только это слово не больше 40
     *  символов).
     *
     *  Дизайн облачка и ASCII-арт допустимо поменять по усмотрению.
     *
     *  Подсказка: обратите внимание на конкатенацию строковых литералов в
     *  языке С, это позволит задавать подобные рисунки так, чтобы они
     *  адекватно выглядели в коде.
     */
  {
    char *str = NULL, ch, *prev_sp, *cur_sp;
    int size = 1, symb = 0;
    int flag = 1;

    std::cout << "6.\n" << "Input message: \n";

    str = new char[size];
    ch = std::cin.get();
    while (ch != '\n')
    {
      if (symb == size - 1)
      {
        char *new_str;
        
        size = size * 2 + 1;
        new_str = new char[size];
        strncpy(new_str, str, symb);
        delete[] str;
        str = new_str;
      }

      str[symb++] = ch;
      ch = std::cin.get();
    }

    str[symb] = '\0';
    std::cout << "\n\n  _____________________________________\n";
    // TODO: выполнить это задание так, чтобы динамическая память не выделялась
    // после считывания строки
    prev_sp = str, cur_sp = str;

    while (*cur_sp != '\0')
    {
      while (*cur_sp != ' ' && *cur_sp != '\0')
      {
        cur_sp++;

        if (cur_sp - prev_sp == 35 && *cur_sp != ' ')
        {
          std::cout << ((flag) ? " / " : " | ");
          while (prev_sp != cur_sp)
          {
            std::cout << *prev_sp;
            prev_sp++;
          }
          std::cout << ((flag) ? " \\ " : " | ") << '\n';
          flag = 0;
          cur_sp++;

          if (*cur_sp == ' ')
            cur_sp++, prev_sp = cur_sp;
        }
      }

      if (*cur_sp == '\0')
        break;

      char *tmp = cur_sp + 1;

      while (*tmp != ' ' && *tmp != '\0')
        tmp++;

      if (cur_sp - prev_sp <= 35 && tmp - prev_sp > 35)
      {
        int l = (int)(cur_sp - prev_sp);

        std::cout << ((flag) ? " / " : " | ");

        while (prev_sp != cur_sp)
        {
          std::cout << *prev_sp;
          prev_sp++;
        }

        for (int i = l; i < 35; i++)
          std::cout << ' ';
        std::cout << ((flag) ? " \\ \n" : " | \n");
        flag = 0;
        cur_sp++;
        prev_sp++;
      }
      else
        cur_sp = tmp + 1;
    }

    int l = (int)(cur_sp - prev_sp);
    
    std::cout << " \\ ";
    while (prev_sp != cur_sp)
    {
      std::cout << *prev_sp;
      prev_sp++;
    }
    for (int i = l; i < 35; i++)
      std::cout << ' ';
    std::cout << " / \n";

    std::cout << "  ------------------------------------\n";
    std::cout <<
      "     \\\n"
      "      \\\n"
      "        /\\_/\\  (\n"
      "       ( ^.^ ) _)\n"
      "         \\\"/  (\n"
      "       ( | | )\n"
      "      (__d b__)\n";

    // Here user input is shown. This line aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa must be at most 40 characters long. aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  }

    /** 
     * Задание 7. Сложные указатели.
     *
     * Объявление и использование указателей на многомерные массивы.
     * Проинициализируйте трехмерный массив double dArray[4][3][3] так, как
     * показано на рисунке и напишите фрагмент кода, который меняет местами
     * значения элементов четных и нечетных слоев:
     *
     *  было:                |--------|     
     *                     / |4  4  4 |     
     *                   |--------| 4 | 
     *                 / |3  3  3 | 4 | 
     *               |---------|3 |   |
     *             / | 2  2  2 |3 | /
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__| 
     *            | 1  1  1 | /
     *            |_________|
     *
     *  стало:               |--------|     
     *                     / |3  3  3 |     
     *                   |--------| 3 | 
     *                 / |4  4  4 | 3 | 
     *               |---------|4 |   |
     *             / | 1  1  1 |4 | /
     *            |---------|1 |__|
     *            | 2  2  2 |1 | /
     *            | 2  2  2 |__| 
     *            | 2  2  2 | /
     *            |_________|
     */

    {
        double **dArray[4];

        for (int i = 0; i < 4; i++)
        {
          dArray[i] = new double * [3];
          for (int j = 0; j < 3; j++)
          {
            dArray[i][j] = new double [3];
            for (int k = 0; k < 3; k++)
              dArray[i][j][k] = i + 1;
          }
        }

        for(int i = 0; i < 3; i += 2)
        {
           double **tmp;
            /** 
             * Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА
             * РАВЕНСТВА!!! 
             */

            tmp = dArray[i];
            dArray[i] = dArray[i + 1];
            dArray[i + 1] = tmp;

            /** переставляем местами элементы i-того и i+1-ого слоев */
        }

        for (int i = 0; i < 4; i++)
        {
          for (int j = 0; j < 3; j++)
            delete[] dArray[i][j];

          delete[] dArray[i];
        }
    }
    
    /**
     * Задание 7.
     */

    /**
     * Задание 7.1.
     *
     * Объявите двухмерный встроенный массив элементов типа char.
     *
     * Сформируйте значения элементов массива с помощью генератора случайных
     * чисел таким образом, чтобы в массиве были только символы '*' и '_'.
     *
     * В каждой строке "сдвиньте звездочки" в начало строки, например:
     * было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
     * стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
     * и распечатайте массив по строкам.
     *
     * При этом оцените количество операций, которое требуется для обработки
     * одной строки относительно длины этой строки.
     *
     * Постарайтесь решить эту задачу так, чтобы требовалось не более k*N 
     * операций, где N - длина строки, k - некое фиксированное число.
     */
    
    {
      std::cout << "7.1\n";

      const int N = 5, M = 25;
      const char symb[2] {'*', '_'};
      char buf[N][M];

      for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
          buf[i][j] = symb[(int)round((float)rand() / RAND_MAX)];

      std::cout << "Before\n";
      for (int i = 0; i < N; i++)
      {
        for (int j = 0; j < M; j++)
          std::cout << buf[i][j];
        std::cout << "\n\n";
      }

      for (int i = 0; i < N; i++)
      {
        int cntzv = 0;

        for (int j = 0; j < M; j++)
          if (buf[i][j] == '*')
            cntzv++;

        for (int j = 0; j < cntzv; j++)
          buf[i][j] = '*';
        for (int j = cntzv; j < M; j++)
          buf[i][j] = '_';
      }

      // для обработки одной строки требуется 2*M действий

      std::cout << "After\n";
      for (int i = 0; i < N; i++)
      {
        for (int j = 0; j < M; j++)
          std::cout << buf[i][j];
        std::cout << "\n\n";
      }
    }

    /**
     * Задание 7.2.
     *
     * Модифицируйте предыдущее задание следующим способом: После заполнения
     * массива с помощью генератора случайных чисел "сдвиньте" звездочки по
     * столбцам вниз и распечатайте результат.
     */

    {
      std::cout << "7.2\n";

      const int N = 5, M = 25;
      const char symb[2] {'*', '_'};
      char buf[N][M];

      for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
          buf[i][j] = symb[(int)round((float)rand() / RAND_MAX)];

      std::cout << "Before\n";
      for (int i = 0; i < N; i++)
      {
        for (int j = 0; j < M; j++)
          std::cout << buf[i][j];
        std::cout << "\n\n";
      }

      for (int j = 0; j < M; j++)
      {
        int cntpod = 0;

        for (int i = 0; i < N; i++)
          if (buf[i][j] == '_')
            cntpod++;

        for (int i = 0; i < cntpod; i++)
          buf[i][j] = '_';
        for (int i = cntpod; i < N; i++)
          buf[i][j] = '*';
      }

      std::cout << "After\n";
      for (int i = 0; i < N; i++)
      {
        for (int j = 0; j < M; j++)
          std::cout << buf[i][j];
        std::cout << "\n\n";
      }
    }

    return 0;
}

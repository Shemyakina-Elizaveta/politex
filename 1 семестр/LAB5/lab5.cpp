/**
 * Практическое занятие №5. "Старые" потоковые функции стандартной библиотеки.
 * Указатели на функции. Структуры.
 */

#include "other.h"
#include "matrix.h"

Book b4;

int main()
{
    /**
     * Задание 1. "Старые" потоковые функции стандартной библиотеки.
     *
     * Эти функции использовались в языке C. Если вы будете писать программы на
     * нем, вам придется использовать их вместо std::cin и std::cout.
     */

    /**
     * Задание 1.1.
     *
     * С помощью функции scanf сформирйуте три коэффициента: A,B,C.
     */
  float A, B, C;

  printf("Input coefficents (A, B, C): ");
  scanf("%f %f %f", &A, &B, &C);

    /**
     * Задание 1.2.
     *
     * Выведите (красиво!) таблицу значений y=A*x*x + B*x + C при изменении x в
     * диапазоне -2 до +2 с шагом 0.5
     */
  for (float x = -2; x <= 2; x += 0.5)
    printf("x = %10.1f, y = %10.2f\n", x, A * x * x + B * x + C);

    /**
     * Задание 2. Указатели на функции.
     */

    /**
     * Задание 2.1. Указатель на функцию. "Калькулятор".
     *
     * Напишите функции:
     * 1. add - принимает два значения double и возвращает сумму этих значений;
     * 2. sub- принимает два значения double и возвращает разность этих
     *    значений;
     * 3. mul - аналогично для умножения;
     * 4. div - аналогично для деления;
     * 5. а для возведения в степень можете использовать функцию стандартной
     *    библиотеки - pow(). 
     *
     * Подсказка 1: прототип функции находится в <cmath>.
     * Подсказка 2: стандартная библиотека предоставляет несколько
     * перегруженных вариантов этой функции, а Вам потребуется сформировать
     * указатель на double pow(double, double).
     *
     * Предоставьте пользователю следующую возможность:
     *
     * - пока пользователь хочет пользоваться услугами вашего калькулятора, он
     *   может вводить два значения и знак операции а вы выводите результат. 
     * - результат получаете посредством вызова соответствующей вашей функции
     *   по указателю.
     * - предусмотрите возможность ввода непредусмотренного знака операции.
     */
  {
    std::cout << "\n\n2.1: \n";

    double (*operations[])(double, double) = {add, sub, mul, div, pow};

    while (true)
    {
      char ch;

      std::cout << "Do you want to continue? (y/n)\n";
      std::cin >> ch;

      if (ch == 'n' || ch == 'N')
        break;

      double a, b, res;
      std::string op;

      std::cout << "Enter a, operation, b: \n";
      std::cin >> a >> op >> b;

      if (op == "+")
        res = operations[0](a, b);
      else if (op == "-")
        res = operations[1](a, b);
      else if (op == "*")
        res = operations[2](a, b);
      else if (op == "/")
        res = operations[3](a, b);
      else if (op == "^")
        res = operations[4](a, b);
      else
        res = -INFINITY;

      if (res == -INFINITY)
        std::cout << "Invalid operation\n";
      else
        std::cout << "Result: " << res << '\n';
    }
  }

    /**
     * Задание 2.2. Указатель на функцию в качестве аргумента.
     *
     * Дана заготовка функции сортировки любых объектов - sort.
     *
     * Функция принимает следующие параметры:
     * 1. указатель на первый сортируемый элемент
     * 2. количество сортируемых элементов
     * 3. размер элемента в байтах
     * 4. указатель на функцию перестановки элементов
     * 5. указатель на функцию сравнения элементов
     */ 

    /**
     * Задание 2.2.1.
     *
     * Напишите функцию перестановки двух целых значений - swap_int, которая
     * принимает два void указателя и меняет значения местами.
     *
     * Напишите функцию сравнения двух целых значений - CmpInt, которая
     * принимает два void указателя и возвращает int результат сравнения:  
     * <0 - первый элемент меньше, чем второй;
     * =0 - равны;
     * >0 - первый элемент больше, чем второй.
     *
     * Используйте эти функции в функции сортировки.
     */
    {
      std::cout << "\n\n2.2.1.:\n";

      int nAr[] = {7, 3, 47, 30, 8, 25, 15};    //массив для сортировки
      int nTotal = 7;          //количество элементов в массиве 

      /** Печать исходного массива */

      std::cout << "Before: \n";
      for (int i = 0; i < nTotal; i++)
        std::cout << nAr[i] << ' ';

      sort(reinterpret_cast<char *>(&nAr[0]), nTotal, sizeof(int), swap_int, cmp_int);

      /** Печать результатов сортировки */
      std::cout << "\nAfter: \n";
      for (int i = 0; i < nTotal; i++)
        std::cout << nAr[i] << ' ';
      
    }

    /**
     * Задание 2.2.2.
     *
     * По аналогии с заданием 2.2.1 напишите функцию swap_double и cmp_double,
     * и вызовите функцию sort для сортировки вещественных значений.
     */
    {
      std::cout << "\n\n2.2.2.:\n";

      double nAr[] = {7, 3, 47, 30, 8, 25, 15};    //массив для сортировки
      int nTotal = 7;          //количество элементов в массиве 

      /** Печать исходного массива */

      std::cout << "Before: \n";
      for (int i = 0; i < nTotal; i++)
        std::cout << nAr[i] << ' ';

      sort(reinterpret_cast<char *>(&nAr[0]), nTotal, sizeof(double), swap_double, cmp_double);

      /** Печать результатов сортировки */
      std::cout << "\nAfter: \n";
      for (int i = 0; i < nTotal; i++)
        std::cout << nAr[i] << ' ';
    }

    /**
     * Задание 2.2.3.
     *
     * По аналогии с 2.2.1 создайте вспомогательные функции - swap_str и
     * cmp_str и вызовите функцию sort для сортировки массива указателей на
     * строки.
     */

    {
      std::cout << "\n\n2.2.3.:\n";

      const char *arStr[] = {"QQQ", "SDF", "ABC"};
      int nTotal = 3;
      int x = 0;

      std::cout << "Before: \n";
      for (int i = 0; i < nTotal; i++)
        std::cout << arStr[i] << ' ';

      sort(reinterpret_cast<char *>(arStr), nTotal, sizeof(char *), swap_str, cmp_str);

      std::cout << "\nAfter: \n";
      for (int i = 0; i < nTotal; i++)
        std::cout << arStr[i] << ' ';
    }

    /**
     * Задание 2.3. Массивы указателей на функцию.
     *
     * Напишите функции для работы с массивом:
     *
     * 1. print_max - печатает максимальный элемент;
     * 2. print_min - печатает минимальный элемент;
     * 3. sort_asc - сортирует по возрастанию и выводит на печать;
     * 4. sort_desc - сортирует по убыванию и выводит на печать.
     *
     * У всех эти функций должна быть одинаковая сигнатура. Объявите, два
     * массива: массив указателей на функции 1-4 и массив указателей на строки
     * с описанием этих функций.
     *
     * Реализуйте меню для пользователя: выведите нумерованный список имен
     * функций (из второго массива), примите от пользователя номер функции,
     * после чего вызовите функцию для какого-нибудь массива.
     */
    {
      std::cout << "\n\n2.3.:\n";
      void (*operations[])(double *, int) = {print_max, print_min, sort_asc, sort_desc};
      const char *descr[] = 
      {
        "0. Exit\n",
        "1. Print maximum element in array\n",
        "2. Print minimum element in array\n",
        "3. Sort in ascending order\n",
        "4. Sort in descending order\n",
      };
      int descr_size = 5;
      
      double nAr[] = {7, 3, 47, 30, 8, 25, 15};    //массив для сортировки
      int nTotal = 7;          //количество элементов в массиве

      while (true)
      {
        std::cout << "Array: ";
        for (int i = 0; i < nTotal; i++)
          std::cout << nAr[i] << ' ';
        std::cout << '\n';

        std::cout << "Enter a command:\n";
        for (int i = 0; i < descr_size; i++)
          std::cout << descr[i];

        int com;

        std::cin >> com;

        if (com == 0)
          break;
        if (com > 4 || com < 0)
          continue;
        operations[com - 1](nAr, nTotal);
      }
    }

    /**
     * Задание 2.4. Метод прямоугольников.
     *
     * Напишите функцию integrate, которая бы принимала:
     * 1. указатель на интегрируемую функцию, которая принимает double и
     *    возвращает double;
     * 2. нижнюю границу интегрирования (вещественное число);
     * 3. верхнюю границу интегрирования (вещественное число);
     * 4. количество отрезков, на которых будет вычисляться функция.
     *
     * Функция должна возвращать численное значение определенного интеграла,
     * полученного методом прямоугольников.
     *
     * Проверьте функцию на разных вещественных функциях (линейных, параболах,
     * exp, sin) и сравните полученные результаты с теоретическими.
     */
    {
      std::cout << "\n\n2.4.: \n";
      std::cout << integrate(sin, 0, 2, 100) << '\n';
      std::cout << integrate(cos, 0, 2, 100) << '\n';
      std::cout << integrate(kvadr, 0, 2, 100) << '\n';
      std::cout << integrate(exp, 0, 2, 100) << '\n';
    }

    /**
     * Задание 3. Структуры С.
     */

    /**
     * Задание 3.1. Структура Book.
     */

    /**
     * Задание 3.1.1.
     *
     * Объявите структуру Book, описывающую книгу (автор, заглавие, год
     * издания, цена, категория…).
     *
     * Подумайте: какого типа могут быть поля структуры.
     * Подсказка: объявление структуры рекомендуется выносить в заголовочный
     * файл.
     */

    /**
     * Задание 3.1.2.
     *
     * Создайте разными способами (глобальный, локальный, статический,
     * динамический) экземпляры (объекты) типа Book (без инициализации).
     *
     * Определите - сколько памяти отводит компилятор под каждый такой объект. 
     *
     * Как инициализируются (или не инициализируются) поля структуры?
     *
     * Подумайте: от чего зависит объем выделяемой памяти?
     */
    {
      Book b1, *b2;
      static Book b3;

      b2 = new Book;

      int x = 0;
      delete b2;

      // b1 - мусор, b2 - мусор, b3 - все по нулям, b4 - все по нулям
      // sizeof(Book) = 40; идет добор до 8 байт
    }
    /**
     * Задание 3.1.3. 
     *
     * Заполните поля созданных объектов.
     *
     * Замечание: если для хранения строки используется массив, необходимо
     * предусмотреть "защиту" от выхода за границы массива.
     */
    {
      Book b1;
      int l1 = std::min(MAX_LENGTH, (int)strlen("Author")), l2 = std::min(MAX_LENGTH, (int)strlen("Title"));

      strncpy(b1.Author, "Author", l1);
      b1.Author[l1] = '\0';
      strncpy(b1.Title, "Title", l2);
      b1.Title[l2] = '\0';
      b1.Year = 2025;
      b1.Cost = 1;
      b1.Type = classical;


    /**
     * Задание 3.1.4. 
     *
     * Напишите функцию, выводящую на экран реквизиты книги.
     *
     * Подумайте: как эффективнее передавать экземпляр Book в функцию.
     *
     * Для вывода на консоль используйте функцию стандартной библиотеки printf.
     */
      std::cout << "\n\n3.1.4: \n";
      print_book(&b1);

    /**
     * Задание 3.1.5.
     *
     * Напишите функцию для формирования полей структуры. Для ввода используйте
     * функцию стандартной библиотеки scanf.
     *
     * Замечание: неплохо заложить в такую функцию возможность проверки
     * корректности введенного значения, например, год издания не может быть
     * меьше, чем... (год появления письменности), категорию ползователь должен
     * выбирать из существующих, цена не может быть отрицательной...
     *
     * Кроме этого необходимо проверить и ошибки другого рода: программа
     * ожидает число, а пользователь ввел случайно букву.
     */
      std::cout << "\n\n3.1.5.: \n";
      Book b2;

      scan_book(&b2);
    }

    /**
     * Задание 3.2. Матричные операции.
     */

    /**
     * Задание 3.2.1. 
     *
     * Задайте структуру Matrix, которая будет преставлять вещественную матрицу
     * размера MxN из линейной алгебры.
     *
     * Это определение и связанные с ними функции определите в отдельной паре
     * файлов: matrix.h и matrix.cpp.
     */

    /**
     * Задание 3.2.2.
     *
     * Создайте набор базовых функций для работы с этой структурой:
     *
     * - void m_zero(Matrix *A, int m, int n) - инициализация матрицы размера m
     *   на n нулями;
     * - void m_id(Matrix *A, int n) - инициализация единичной матрицы n на n;
     * - void m_free(Matrix *A) - очистка памяти, используемой для матрицы;
     * - void m_copy(const Matrix *src, Matrix *dst) - копирование данных
     *   матрицы src в матрицу dst.
     * - int m_width(const Matrix *A) - ширина матрицы A;
     * - int m_height(const Matrix *A) - высота матрицы A;
     * - double m_get(const Matrix* A, int i, int j) - получение i,j-того
     *   элемента матрицы;
     * - void m_set(Matrix *A, int i, int j, double value) - установка i,j-того
     *   элемента матрицы.
     */
    {
      std::cout << "\n\n3.2.2: \n";
      Matrix A;

      m_free(&A);
      m_zero(&A, 4, 4);
      std::cout << "w: " << m_width(&A) << " h: " << m_height(&A) << '\n';
      std::cout << "[0, 0]: " << m_get(&A, 0, 0) << " [5, 6]: " << m_get(&A, 5, 6) << '\n';

    /**
     * Задание 3.2.3.
     *
     * Реализуйте набор операций из линейной алгебры:
     *
     * - int m_add(Matrix *A, const Matrix *B) - если A и B одинакового
     *   размера, то прибавляет к A значения B и возвращает 0; иначе возвращает
     *   1.
     * - void m_neg(Matrix *A) - заменяет все элементы матрицы A на
     *   противоположные.
     * - int m_mult(const Matrix *A, const Matrix *B, Matrix *dst) - умножает
     *   матрицу A на матрицу B и сохраняет результат в dst. Если размеры
     *   матрицы не позволяют умножить матрицы, функция возвращает 1, иначе 0.
     */

      Matrix B, C, D;

      m_id(&B, 4);
      m_add(&A, &B);
      // m_neg(&A);
      
      m_free(&B);
      m_zero(&B, 3, 2);
      m_set(&B, 0, 0, 1);
      m_set(&B, 0, 1, 1);
      m_set(&B, 1, 0, 2);
      m_set(&B, 1, 1, 2);
      m_set(&B, 2, 0, 3);
      m_set(&B, 2, 1, 3);

      m_free(&C);
      m_zero(&C, 2, 3);
      m_set(&C, 0, 0, 1);
      m_set(&C, 0, 1, 1);
      m_set(&C, 0, 2, 1);
      m_set(&C, 1, 0, 2);
      m_set(&C, 1, 1, 2);
      m_set(&C, 1, 2, 2);

      m_mult(&B, &C, &D);
    }

    /**
     * Задание 3.2.4.
     *
     * С помощью полученного функционала реализуйте матричное вычисление чисел
     * Фибоначчи. Делается это с помощью такой формулы:
     *
     * /  F[n]  \ = / 1  1 \ * / F[n-1] \
     * \ F[n-1] /   \ 1  0 /   \ F[n-2] /
     *
     * Задайте матрицу в центре и матрицу-вектор с двумя первыми числами
     * Фибоначчи: 1 и 0. Выполняйте эту формулу итеративно и выведите первые 40
     * чисел Фибоначчи.
     */
    {
      std::cout << "3.2.4: \n";

      Matrix Fib, PrevFib, Id;

      m_zero(&Id, 2, 2);
      m_set(&Id, 0, 0, 1);
      m_set(&Id, 0, 1, 1);
      m_set(&Id, 1, 0, 1);

      m_zero(&PrevFib, 2, 1);
      m_set(&PrevFib, 0, 0, 1);
      m_set(&PrevFib, 1, 0, 0);

      std::cout << "0 ";
      for (int i = 2; i < 41; i++)
      {
        m_mult(&Id, &PrevFib, &Fib);
        std::cout << m_get(&Fib, 1, 0) << ' ';
        m_copy(&Fib, &PrevFib);
      }
    }

    return 0;
}
